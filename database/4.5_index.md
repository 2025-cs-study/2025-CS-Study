## 4.5 인덱스

### 4.5.1 인덱스의 필요성
- **인덱스(Index)**: 데이터를 빠르게 찾을 수 있는 하나의 장치임.

    - 인덱스를 설정하면 테이블 안에서 원하는 데이터를 빠르게 찾을 수 있음.

### 4.5.2 B-트리
- 인덱스는 주로 B-트리라는 자료 구조로 이루어짐.

    - **B-트리**: 루트 노드, 리프 노드, 브랜치 노드로 나뉨.

      ```sql
      -- B-트리 예
                                  [10 | 20]                             --(루트 노드)
                    /                 |                 \
              [5 | 7]             [12 | 15]             [25 | 30]       --(브랜치 노드)
            /   |   \             /      \               /      \
         [1|3] [6] [8|9]       [11]    [13|14]         [22]   [28|29]   --(리프 노드)
      ```
    - 인덱스의 효율성은 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 트리 깊이의 대수확장성 때문임.

### 4.5.3 인덱스 만드는 방법
- 데이터베이스마다 인덱스를 만드는 방법은 다름.

    - **MySQL**:

        - **클러스터형 인덱스**: 테이블당 하나를 설정할 수 있음. 주로 primary key나 unique not null 옵션으로 만들 수 있음.
        - **세컨더리 인덱스**: 보조 인덱스로, 여러 개의 필드 값을 기반으로 쿼리가 많이 이루어질 때 생성해야 하는 인덱스. `CREATE INDEX ...` 명령어로 만들 수 있음.

    - **MongoDB**:

        - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨. 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음.

### 4.5.4 인덱스 최적화 기법
- 데이터베이스마다 다르지만 기본 골조는 같음.

    - **MongoDB 기반 인덱스 최적화 기법**:

        - 인덱스는 비용임.

            - 인덱스는 두 번(인덱스 리스트, 컬렉션 순) 탐색하도록 강요함.
            - 컬렉션이 수정되었을 때 인덱스도 수정되어야 함.
            - 쿼리에 있는 필드에 인덱스를 무작정 설정하는 것은 답이 아님.

        - 항상 테스팅해야 함. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 항상 테스팅하는 것이 중요함.

        - 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함. 여러 필드를 기반으로 조회할 때 복합인덱스를 생성하는데 아래 생성 순서에 따라 성능이 달라질 수 있음.

## ⁉️예상 질문

1. `Index`와 `Index의 장/단점`에 대해 설명해주세요.
2. 인덱스를 매 필드마다 설정하는 것이 좋을까요?
3. Index의 `B+ 트리`가 무엇인지 설명해주세요.
4. `해시 인덱스 방식`과 `B+ 트리 인덱스 방식`의 차이에 대해 설명해주세요.
5. DBMS는 Index를 어떻게 관리하고 있나요?(Index 자료구조)

&nbsp;

※ 자세한 내용은 [블로그](https://mandusitstudy.tistory.com/315)를 참고해주세요.